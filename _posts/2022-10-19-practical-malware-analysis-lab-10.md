---
title: "Practical Malware Analysis - Lab 10 write-up"
tags:
  - Practical Malware Analysis
---
![](/assets/images/practical_malware_analysis.png)<br>
Kernel Debugging with WinDbg is the subject of Chapter 10. From this chapter I learned:
- How to set-up kernel debugging on a VM
- Useful commands for kernel debugging with WinDbg
- That the **major function table** tells us what is executed when a driver is called from user space
- That **DeviceIoControl** is a common request for a malicious kernel component 
- That **System Service Descriptor Table (SSDT) hooking** is a technique used by rootkits to modify the kernel

This was my first experience with kernel debugging, so the labs took me quite some time to get through. 

## Lab 10-1
*This lab includes both a driver and an executable. You can run the executable from anywhere, but in order for the program to work properly, the driver must be placed in the <code>C:\Windows\System32</code> directory where it was originally found on the victim computer. The executable is Lab10-01.exe, and the driver is Lab10-01.sys.* 

**1. Does this program make any direct changes to the registry? (Use procmon to check.)**<br> 
**Answer:** Yes, but I could not find these changes in procmon. Regshot comparison results show that the following registry keys were added:
- <code>HKLM\SOFTWARE\Policies\Microsoft\WindowsFirewall</code>
- <code>HKLM\SOFTWARE\Policies\Microsoft\WindowsFirewall\DomainProfile</code>
- <code>HKLM\SOFTWARE\Policies\Microsoft\WindowsFirewall\StandardProfile</code>
- <code>HKLM\SYSTEM\ControlSet001\Enum\Root\LEGACY_LAB10-01</code>
- <code>HKLM\SYSTEM\ControlSet001\Enum\Root\LEGACY_LAB10-01\0000</code>
- <code>HKLM\SYSTEM\ControlSet001\Enum\Root\LEGACY_LAB10-01\0000\Control</code>
- <code>HKLM\SYSTEM\ControlSet001\Services\Lab10-01</code>
- <code>HKLM\SYSTEM\ControlSet001\Services\Lab10-01\Security</code>
- <code>HKLM\SYSTEM\ControlSet001\Services\Lab10-01\Enum</code>
- <code>HKLM\SYSTEM\CurrentControlSet\Enum\Root\LEGACY_LAB10-01</code>
- <code>HKLM\SYSTEM\CurrentControlSet\Enum\Root\LEGACY_LAB10-01\0000</code>
- <code>HKLM\SYSTEM\CurrentControlSet\Enum\Root\LEGACY_LAB10-01\0000\Control</code>
- <code>HKLM\SYSTEM\CurrentControlSet\Services\Lab10-01</code>
- <code>HKLM\SYSTEM\CurrentControlSet\Services\Lab10-01\Security</code>
- <code>HKLM\SYSTEM\CurrentControlSet\Services\Lab10-01\Enum</code>

**2. The user-space program calls the ControlService function. Can you set a breakpoint with WinDbg to see what is executed in the kernel as a result of the call to ControlService?** <br>
**Answer:** To see what is executed in the kernel as a result of the call to <code>ControlService</code>, I first used WinDbg inside the VM to set a breakpoint @ 00401080. This is where the call to <code>ControlService</code> is executed.
![](/assets/images/Pasted image 20221014103202.png)<br>
![](/assets/images/Pasted image 20221014103458.png)<br>
With the breakpoint hit, I switched over to the instance of WinDbg Preview on my host machine. This is attached to the kernel of the VM through a pipe set to <code>\\.\pipe\MalDBG</code> and a baud rate of 115200.
![](/assets/images/Pasted image 20221014103715.png)<br>
With the kernel debugger connection established, we can search for the driver object to the Lab10-01 service:
![](/assets/images/Pasted image 20221014104351.png)<br>
In this case, the address of the driver object is <code>89f4e030</code>. We can now view its structure using the <code>dt _DRIVER_OBJECT 89f4e030</code> command:
![](/assets/images/Pasted image 20221014104906.png)<br>
Since we want to find out what is executed in the kernel **as a result of the call to <code>ControlService</code>**, we can set a breakpoint in our kernel debugger at <code>DriverUnload</code> (located at <code>0xf7abd486</code>). After resuming the kernel and continuing execution on the VM, we hit our breakpoint:
![](/assets/images/Pasted image 20221014110538.png)<br>
We can now step through the code and see that it is accessing registry keys:
![](/assets/images/Pasted image 20221014112113.png)<br>
Stepping through the instructions above will reveal the same information as the things that we see when analysing the <code>Lab10-01.sys</code> driver in IDA. 
![](/assets/images/Pasted image 20221014112234.png)<br>

**3. What does this program do?**<br>
**Answer:** The program creates a service named "Lab10-01" with its path set to the <code>Lab10-01.sys </code> driver:
![](/assets/images/Pasted image 20221014093638.png)<br>
The driver disables the firewall on the target system by setting the following registry values to 0x00000000:
- <code>HKLM\SOFTWARE\Policies\Microsoft\WindowsFirewall\DomainProfile\EnableFirewall</code>
- <code>HKLM\SOFTWARE\Policies\Microsoft\WindowsFirewall\StandardProfile\EnableFirewall</code>

![](/assets/images/Pasted image 20221014100204.png)<br>

### Comparing my answers to the Lab 10-1 solutions
Conclusions after comparison:
- We could not find the changes in registry in procmon, because direct changes to the registry from the kernel go undetected by procmon.

## Lab 10-2
*The file for this lab is Lab10-02.exe.* 

**1. Does this program create any files? If so, what are they?** <br>
**Answer:** Yes, we can see that the program creates a driver file named <code>Mlwx486.sys</code> in <code>C:\Windows\System32</code>.
![](/assets/images/Pasted image 20221014131851.png)<br>
In the .rsrc section of the program we also see that the file contains another PE header:
![](/assets/images/Pasted image 20221014133800.png)<br>
The program uses the <code>C:\Windows\System32\Mlwx486.sys</code> file in a newly created service called <code>486 WS Driver</code>:
![](/assets/images/Pasted image 20221014133008.png)<br>

**2. Does this program have a kernel component?**<br>
**Answer:** Yes, if we query the service that is created we see that it is a kernel driver:
![](/assets/images/Pasted image 20221014134248.png)<br>

**3. What does this program do?**<br>
**Answer:** The program creates the <code>C:\Windows\System32\Mlwx486.sys</code> file and uses this path in a newly created service named "486 WS Driver". This is a kernel driver. If we search for the <code>C:\Windows\System32\Mlwx486.sys</code> file, we cannot find it. 

Exporting and analysing the executable within the .rsrc section of the program, we learn that this is actually the kernel driver. The driver has a very interesting string that contains the word "rootkit":
![](/assets/images/Pasted image 20221014135823.png)<br>
Since the book mentioned that a technique called **System Service Descriptor Table (SSDT) hooking** is often used by rootkits, I checked the SSDT to see if any entries were overwritten. One of the memory locations immediately stands out:<br>
![](/assets/images/Pasted image 20221014141018.png)<br>
This entry is in a memory location that is outside the bounds of the ntoskrnl module. If we look at the loaded modules we see that the range should be between 804d7000 and 806ed680:
![](/assets/images/Pasted image 20221014141254.png)<br>
It is now clear that the program is hooking into a function in order to hide the <code>Mlwx486.sys</code> file that is located in <code>C:\Windows\System32</code>.


### Comparing my answers to the Lab 10-2 solutions
Conclusions after comparison:
- We could have found the name of the function that the rootkit is hooking into by reverting our virtual machine to a state before the rootkit was installed. In this state, we could have looked at the offset into the SSDT that was overwritten. In this case, the function is <code>NtQueryDirectoryFile</code>, which we could also see when analysing the malicious driver file in IDA:
	- ![](/assets/images/Pasted image 20221014141859.png)<br>

## Lab 10-3
*This lab includes a driver and an executable. You can run the executable from anywhere, but in order for the program to work properly, the driver must be placed in the <code>C:\Windows\System32</code> directory where it was originally found on the victim computer. The executable is Lab10-03.exe, and the driver is Lab10-03.sys.* 

**1. What does this program do?** <br>
**Answer:** The program first creates a new service that uses the <code>C:\Windows\System32\Lab10-03.sys</code> driver path. The name of this service is <code>Process Helper</code>:
![](/assets/images/Pasted image 20221014144436.png)<br>
After this, a file named <code>\\.\ProcHelper</code> is created:
![](/assets/images/Pasted image 20221014145154.png)<br>
This <code>\\.\ProcHelper</code> file is a device object that the malware can use. Once the malware has a handle to the device object, it uses the <code>DeviceIoControl</code> function:
![](/assets/images/Pasted image 20221014145550.png)<br>
The program then uses the Component Object Model (COM). Each thread that uses COM must call the **OleInitialize** or **ConInitializeEx** function at least once prior to calling any other COM library functions. The imports table of this program shows <code>OleInitialize</code>:<br>
![](/assets/images/Pasted image 20221014143558.png)<br>
Further analysis shows that COM is used to open the <code>http://www.malwareanalysisbook.com/ad.html</code> page:
![](/assets/images/Pasted image 20221014143725.png)<br>
![](/assets/images/Pasted image 20221014143742.png)<br>
After opening this page, the program seems to be stuck in an infinite loop, sleeping for 30 seconds every time.
![](/assets/images/Pasted image 20221014143954.png)<br>
Dynamic analysis shows that the <code>http://www.malwareanalysisbook.com/ad.html</code> page pops up every 30 seconds.

**2. Once this program is running, how do you stop it?** <br>
**Answer:** I could not find a way to stop the program. It cannot be found in the list of processes.


**3. What does the kernel component do?**<br>
**Answer:** Examining the imports of the <code>C:\Windows\System32\Lab10-03.sys</code> file strongly hints that the kernel component hides the malicious process, as we also noticed in our answer to question 2. In the imports table we see that the program may use the <code>IoGetCurrentProcess</code> function of the <code>ntoskrnl</code> library. 
![](/assets/images/Pasted image 20221018124409.png)<br>
We can also see that the kernel file creates a device called <code>ProcHelper</code>:
![](/assets/images/Pasted image 20221018130313.png)<br>
I then looked for this device object in WinDbg. The information below shows us where the DriverObject is loaded in memory.
![](/assets/images/Pasted image 20221018131204.png)<br>
Now we can examine the function pointers of this driver object and get the offset to <code>MajorFunction</code>:
![](/assets/images/Pasted image 20221019091728.png)<br>
Since the offset is +0x38, we could use the <code>dd 8a254da0+0x38</code> command to view the contents of the major function table:
![](/assets/images/Pasted image 20221019092044.png)<br>
But since I'm using WinDbg Preview, we can just click on <code>MajorFunction</code> and it will automatically run a command that also gets the function names:
![](/assets/images/Pasted image 20221019093347.png)<br>
We see a lot of <code>0x804fa87e</code> entries, which point to the <code>IopInvalidDeviceRequest</code> function. This function does not seem that interesting. All it does it set the status to indicate that the operation requested is invalid for this device type. 

This leaves 3 more interesting entries in the major function table:
![](/assets/images/Pasted image 20221019100705.png)<br>
Note that 2 of these entries are pointing to the same address: <code>0xf7a76606</code>. This means we have 2 possibly interesting functions that the driver object uses. Located at <code>0xf7a76606</code> and <code>0xf7a76666</code>.
The function at offset 0x606 simply calls <code>IofCompleteRequest</code> and then returns:
![](/assets/images/Pasted image 20221019104500.png)<br>
The function at offset 0x666 looks a lot more interesting. It calls the <code>IoGetCurrentProcess</code> function, which according to [Microsoft documentation](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-iogetcurrentprocess) returns a pointer to the current process. It then performs some mov and add instructions before calling <code>IofCompleteRequest</code> and returning. I believe that this function is used to hide the malicious process from the process listing. 
![](/assets/images/Pasted image 20221019105435.png)<br>

### Comparing my answers to the Lab 10-3 solutions
Conclusions after comparison:
- We could've further examined the kernel component of this program to discover the following:
	- The call to <code>IoGetCurrentProcess</code> in the function at offset 0x666 returns the <code>EPROCESS</code> structure. It then accesses the data at an offset of 0x88 by performing the <code>add eax, 88h</code> instruction. 
	  ![](/assets/images/Pasted image 20221019111028.png)<br>
	  We can view the EPROCESS structure with the <code>dt nt!_EPROCESS</code> command in WinDbg:
	  ![](/assets/images/Pasted image 20221019111156.png)<br>
	  <code>LIST_ENTRY</code> is stored at offset 0x88. This structure is a double-linked list with two values: <code>BLINK</code> - which points to the previous entry in the list, and <code>FLINK</code> - which points to the next entry in the list.
	  Let's go back to the function at offset 0x666.
	  ![](/assets/images/Pasted image 20221019111941.png)<br>
	  The <code>mov ecx, [eax+8Ch]</code> instruction obtains a pointer to the next entry in the list. 
	  The <code>add eax, 88h</code> instruction accesses the <code>LIST_ENTRY</code> structure. 
	  The <code>mov edx, [eax]</code> instruction obtains a pointer to the previous entry in the list.
	  The <code> mov [ecx], edx</code> instruction overwrites the BLINK pointer of the next entry pointed to the current entry.
	  The next mov instructions perform the same steps, except to overwrite the FLINK pointer of the previous entry in the list to skip the current entry.
	  
	  These instructions hide the current process by unlinking it from the linked list of loaded process, as displayed in the figure below:
	  ![](/assets/images/Pasted image 20221019112634.png)<br>
	  When the OS is running normally, each process has a pointer to the process before and after it. In the figure above, process number 2 has been hidden by the rootkit. 

### Sources
- [Book: Practical Malware Analysis by Michael Sikorski and Andrew Honig](https://nostarch.com/malware)
- [IopInvalidDeviceRequest Windows function](https://www.codewarrior.cn/ntdoc/winnt/io/IopInvalidDeviceRequest.htm)
- [IoGetCurrentProcess Windows function](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-iogetcurrentprocess)