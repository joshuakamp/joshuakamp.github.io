---
title: "Practical Malware Analysis - Lab 9 write-up"
tags:
  - Practical Malware Analysis
---
![](/assets/images/practical_malware_analysis.png)<br>
Since Chapter 8 did not include any lab assignments, we continue this series with Chapter 9: OllyDbg. From this Chapter we (obviously) learned about OllyDbg usage, but also about rebasing, debugging DLLs, debugging techniques (such as tracing), and analysing shellcode. We finally picked up enough skills to revisit a malware sample that we got stuck on in Chapter 3. Let's go!

## Lab 9-1 
*Analyze the malware found in the file Lab09-01.exe using OllyDbg and IDA Pro to answer the following questions. This malware was initially analyzed in the Chapter 3 labs using basic static and dynamic analysis techniques.* 

**1. How can you get this malware to install itself?** <br>
**Answer:** This was quite a painful process to get through. I remembered from the Chapter 3 labs that this sample required additional command line arguments in order to install itself, with one possible argument being "-in". The "-in" option would make most sense, since it could stand for "install".

OllyDbg makes it easy to debug programs with additional arguments, as you can see in the screenshot below.<br>
![](/assets/images/Pasted image 20220930142047.png)<br>
You can also pass arguments from the **Debug --> Arguments** option in the menu at the top of the program. Anyhow, when debugging the program we eventually notice that it deletes itself by calling **ShellExecuteA** @ 0x004024EE with the <code>/c del</code> <code>[PATH TO LAB09-01.EXE]</code> parameters passed to cmd.exe. So the "-in" argument is not correct.<br>
![](/assets/images/Pasted image 20220930141829.png)<br>
One thing that is interesting about this malware is that it starts at 0x00403896, instead of the regular 0x00400000 base address of executables. We can see this in the **Exports** window when we view the program in IDA Pro:<br>
![](/assets/images/Pasted image 20220930143325.png)<br>
When we open this function, IDA even gives us a warning that this may contain trojan horses, viruses, and do harmful things:<br>
![](/assets/images/Pasted image 20220930143447.png)<br>
Further examination of this function shows that it looks at command line arguments supplied to the program and the environment strings. It pushes these onto the stack before calling main:<br>
![](/assets/images/Pasted image 20220930143732.png)<br>
When main is called, it compares argc (number of arguments) to 1. This is followed by a jnz instruction (Jump Not Zero). So if the result of this comparison is zero (this means that there is only 1 argument) we do not take the jump to short loc_402B1D. Instead, we take the path of the red arrow. Note that the program itself (Lab09-01.exe) counts as the first argument. So if there are no additional arguments, we take the path of the red arrow (not taking the jump).<br>
![](/assets/images/Pasted image 20220930145027.png)<br>
We already know that this malware will not install itself without the correct arguments specified, and if we follow the path of the red arrow we also see that **ShellExecuteA** eventually gets called.<br>
![](/assets/images/Pasted image 20220930145807.png)<br>
When we debugged the program we already learned that this call is used to delete itself (note that the memory address 004024EE is the same as in the debugger). This function has a few other xrefs, so I am renaming it to "SELFDESTRUCT" to make analysis easier:<br>
![](/assets/images/Pasted image 20220930145934.png)<br>
If we follow the path of the green arrow, we see that **argc** (argument count: int that stores the number of command-line arguments passed, including the name of the program) and **argv** (argument vector: array of character pointers listing all the arguments) are referenced before a new function is called. <br>
![](/assets/images/Pasted image 20220930151548.png)<br>
Notice the <code>mov edx, [ecx+eax*4-4]</code> instruction @ 00402B23. This accesses the last element in argv. This element is passed to the <code>sub_402510</code> function as a parameter. Since it seems like this function would check for the correct argument being passed, I set a breakpoint on the call instruction @ 00402B2E in OllyDbg. I then checked what would happen if I ran the program with the command-line arguments "-in blabla".<br>
![](/assets/images/Pasted image 20221004120059.png)<br>
When we hit our breakpoint, we see that "blabla" is passed as a parameter to the new function:<br>
![](/assets/images/Pasted image 20221004120256.png)<br>
Stepping through the new function, we eventually hit a <code>CMP ECX, 4</code> instruction @ 00402524:<br>
![](/assets/images/Pasted image 20221004120515.png)<br>
In the registers view, we see that ECX contains 6. It looks like the program is checking for the number of characters that are in our second command-line argument (blabla). It is expecting a total of 4 characters, as with out 6 character input we eventually hit the SELFDESTRUCT function again...

So let's try again by running the program with the command-line arguments "-in 1234":<br>
![](/assets/images/Pasted image 20221004121029.png)<br>
This time, ECX is equal to 4. So we will take the jump to 0040252D.<br>
![](/assets/images/Pasted image 20221004121321.png)<br>
Here we eventually hit a <code>CMP EDX, 61</code> instruction. EDX contains 31 with our input, and we eventually hit the SELFDESTRUCT function again. Note that 0x31 is "1" in ASCII. So the first character in our second command-line argument is being checked against 0x61 here!<br>
![](/assets/images/Pasted image 20221004122115.png)<br>
Since 0x61 is "a" in ASCII, I ran the program again with the command-line arguments "-in a234". This lead to taking the jump to 00402542. <br>
![](/assets/images/Pasted image 20221005100100.png)<br>
Now, these instructions might be a bit unclear at first sight. But if you step through the program you will notice that it subtracts the hex value of character 2 from the hex value of character 1. As mentioned before, 0x61 is "a". 0x32 is "2", so in this case the program will subtract 0x61 from 0x32. We do not take the jump @ 0040255A, since the result of this subtraction is not equal to 1.<br>
![](/assets/images/Pasted image 20221005100539.png)<br>
You can confirm that 0x32 - 0x61 is FFFFFFD1 (or -47 in decimal) by using a hex calculator.<br>
![](/assets/images/Pasted image 20221005100715.png)<br>
To take the jump, we will need to get a result of 1 from this subtraction instruction. 0x62 - 0x61 = 1, so the second character must be "b" since "b" is the ASCII value for 0x62!

Let's try again by running the program with the command-line arguments "-in ab34".<br>
![](/assets/images/Pasted image 20221005101146.png)<br>
And we can see that we successfully take the jump.<br>
![](/assets/images/Pasted image 20221005101328.png)<br>
At this set of instructions we see a reference to 0x63, which is "c" in ASCII. Could this be our next character?<br>
![](/assets/images/Pasted image 20221005101922.png)<br>
EAX and EDX now both contain 0x63. We take the jump!<br>
![](/assets/images/Pasted image 20221005102219.png)<br>
At the next set of instructions, 0x1 gets added to 0x63 and our final character is compared against the result. Since 0x64 is "d" in ASCII we now know the full password: "abcd"!

Now we can finally answer this question. To get the malware to install itself, we have to supply it with the command-line arguments: "-in abcd".

**2. What are the command-line options for this program? What is the password requirement?** <br> 
**Answer:** All of the command-line options can actually be seen when running the malware in a debugger. They can be found in the memory dump window. The command-line options are: 
- <code>-cc</code>
- <code>-c</code>
- <code>-re</code>
- <code>-in</code>

![](/assets/images/Pasted image 20221005103627.png)<br>
The password requirement is <code>abcd</code>, as already mentioned in the previous answer.

**3. How can you use OllyDbg to permanently patch this malware, so that it doesnâ€™t require the special command-line password?** <br>
**Answer:** In IDA, you can easily notice that the password checking function always returns 0 if the password is incorrect by XORing EAX with EAX. If the password is correct, "1" gets moved into EAX before returning:<br>
![](/assets/images/Pasted image 20221005105246.png)<br>
So to get the program to not require a special command-line password, you could patch the "xor eax, eax" instruction to "mov eax, 1". This way the program will always return 1 and continue executing.

**4. What are the host-based indicators of this malware?** <br>
**Answer:** The host-based indicators of this malware are:
- <code>HKLM\SOFTWARE\Microsoft \XPS</code>
	- Notice the space after Microsoft!
- <code>HKLM\SYSTEM\ControlSet001\Services\Lab09-01\Security</code>
- <code>HKLM\SYSTEM\CurrentControlSet\Services\Lab09-01\Security</code>
- Service named <code>Lab09-01 Manager Service</code>
- <code>C:\WINDOWS\system32\Lab09-01.exe</code>

![](/assets/images/Pasted image 20221005110919.png)<br>
![](/assets/images/Pasted image 20221005111151.png)<br>
![](/assets/images/Pasted image 20221005111331.png)<br>

**5. What are the different actions this malware can be instructed to take via the network?** <br>
**Answer:** These commands can be found in the <code>sub_402020</code> function in IDA. They are:
- <code>SLEEP</code>
- <code>UPLOAD</code>
- <code>DOWNLOAD</code>
- <code>CMD</code>
- <code>NOTHING</code>

![](/assets/images/Pasted image 20221005114746.png)<br>
![](/assets/images/Pasted image 20221005114838.png)<br>
![](/assets/images/Pasted image 20221005114924.png)<br>
![](/assets/images/Pasted image 20221005115018.png)<br>
![](/assets/images/Pasted image 20221005115208.png)<br>


**6. Are there any useful network-based signatures for this malware?** <br>
**Answer:** The network-based signature for this malware is:
- <code>http://www.practicalmalwareanalysis.com</code>

![](/assets/images/Pasted image 20221005112714.png)<br>


### Comparing my answers to the Lab 9-1 solutions
Conclusions after comparison:
- The command-line options that I mentioned in question 3 were correct, but I forgot to note what each option does:
	- <code>-in</code>
		- Installs a service
	- <code>-re</code>
		- Removes a service
	- <code>-c</code>
		- Updates the malware configuration in the registry
	- <code>-cc</code>
		- Reads the current configuration from the registry and formats it into a string which is printed to the console
- I also forgot to mention what each network command does...
	- <code>SLEEP</code>
		- Sleeps for the specified amount of seconds
	- <code>UPLOAD</code>
		- Creates a specified file on the local system by connecting to the remote host over a specified port
	- <code>DOWNLOAD</code>
		- Reads a specified file and sends it to the remote host over a specified port
	- <code>CMD</code>
		- Executes the specified shell command with cmd.exe and sends the output to the remote host over a specified port
	- <code>NOTHING</code>
		- Does nothing

## Lab 9-2 
*Analyze the malware found in the file Lab09-02.exe using OllyDbg to answer the following questions.* 

**1. What strings do you see statically in the binary?** <br> 
**Answer:** The only interesting string I see when statically looking at the program is <code>cmd</code>.

**2. What happens when you run this binary?** <br>
**Answer:** Nothing happens. The program exits right away.

**3. How can you get this sample to run its malicious payload?** <br>
**Answer:** When debugging the program, I noticed that it references its file name <code>Lab09-02.exe</code> multipe times. Eventually, we can see it pushing both <code>Lab09-02.exe</code> and <code>ocl.exe</code> onto the stack before calling a strcmp function:<br>
![](/assets/images/Pasted image 20221005141826.png)<br>
We know that this is a strcmp function, because if we search for the same address in IDA we can see that it has been nicely labeled for us:<br>
![](/assets/images/Pasted image 20221005141942.png)<br>
If we rename the program to <code>ocl.exe</code>, it actually executes its malicious payload!

**4. What is happening at 0x00401133?** <br>
**Answer:** We see two strings being initialized in this area. One string contains "1qaz2wsx3edc" and the other string contains "ocl.exe".<br>
![](/assets/images/Pasted image 20221005142648.png)<br>

**5. What arguments are being passed to subroutine 0x00401089?** <br>
**Answer:** Before the subroutine is called, we see that <code>var_1F0</code> and <code>Str</code> are pushed onto the stack.<br>
![](/assets/images/Pasted image 20221005144704.png)<br>
We already know that <code>Str</code> contains "1qaz2wsx3edc". <code>var_1F0</code> does not seem to contain anything interesting yet, but when we look at it in OllyDbg it holds a memory address which points to some kind of encoded string:<br>
![](/assets/images/Pasted image 20221005152752.png)<br>

When we step through the sub_401089 function in OllyDbg we see that it returns an interesting URL!<br>
![](/assets/images/Pasted image 20221005145621.png)<br>

**6. What domain name does this malware use?** <br>
**Answer:** <code>www.practicalmalwareanalysis.com</code>

**7. What encoding routine is being used to obfuscate the domain name?** <br>
**Answer:** The domain is encoded with a XOR routine.

**8. What is the significance of the CreateProcessA call at 0x0040106E?** <br>
**Answer:** Before this call, a socket is created in order to connect to <code>practicalmalwareanalysis.com</code> on port 9999. The <code>CreateProcessA</code> call points all input and output of cmd.exe to this socket. This means that a reverse shell is created in order to receive commands from the attacker.<br>
![](/assets/images/Pasted image 20221005165158.png)<br>

### Comparing my answers to the Lab 9-2 solutions
Conclusions after comparison:
- No differences here!

## Lab 9-3 
*Analyze the malware found in the file Lab09-03.exe using OllyDbg and IDA Pro. This malware loads three included DLLs (DLL1.dll, DLL2.dll, and DLL3.dll) that are all built to request the same memory load location. Therefore, when viewing these DLLs in OllyDbg versus IDA Pro, code may appear at different memory locations. The purpose of this lab is to make you comfortable with finding the correct location of code within IDA Pro when you are looking at code in OllyDbg.* 

**1. What DLLs are imported by Lab09-03.exe?** <br>
**Answer:** If we look at the import table of <code>Lab09-03.exe</code>, we see that the following DLLs are imported:
- <code>DLL1</code>
- <code>DLL2</code>
- <code>KERNEL32</code>
- <code>NETAPI32.dll</code>

When viewing the import table, we also see that the <code>LoadLibraryA</code> function of KERNEL32 is used. This function can be used to dynamically load additional DLLs. 
![](/assets/images/Pasted image 20221005171007.png)<br>
Looking at the xrefs to <code>LoadLibraryA</code>, we learn that there are two additional DLLs being loaded by Lab09-03.exe:
- <code>DLL3.dll</code>
- <code>user32.dll</code>

![](/assets/images/Pasted image 20221005171133.png)<br>
![](/assets/images/Pasted image 20221005171211.png)<br>

**2. What is the base address requested by DLL1.dll, DLL2.dll, and DLL3.dll?** <br>
**Answer:** <code>0x10000000</code>

**3. When you use OllyDbg to debug Lab09-03.exe, what is the assigned based address for: DLL1.dll, DLL2.dll, and DLL3.dll?** <br>
**Answer:** The assigned base addresses are:
- <code>0x00330000</code> for DLL2
- <code>0x00390000</code> for DLL3
- <code>0x10000000</code> for DLL1

![](/assets/images/Pasted image 20221005173310.png)<br>

**4. When Lab09-03.exe calls an import function from DLL1.dll, what does this import function do?** <br>
**Answer:** It calls <code>DLL1Print</code>, which prints "DLL 1 mystery data %d" onto the screen. Note that %d is a format specifier for decimal integers, so this "mystery data" is probably a number.<br>
![](/assets/images/Pasted image 20221005174321.png)<br>
![](/assets/images/Pasted image 20221005174529.png)<br>

**5. When Lab09-03.exe calls WriteFile, what is the filename it writes to?** <br>
**Answer:** We can see that <code>WriteFile</code> is called after calling <code>DLL2ReturnJ</code>. The return value from this <code>DLL2ReturnJ</code> call is stored in **hFile**, which is pushed onto the stack before calling <code>WriteFile</code>. 
![](/assets/images/Pasted image 20221005175745.png)<br>
The <code>DLL2ReturnJ</code> function stores a dword into EAX before returning. If we look at the DllMain function, we learn that this dword is <code>temp.txt</code>. So the filename that it writes to is: <code>temp.txt</code><br>
![](/assets/images/Pasted image 20221005192149.png)<br>
![](/assets/images/Pasted image 20221005192255.png)<br>

**6. When Lab09-03.exe creates a job using NetScheduleJobAdd, where does it get the data for the second parameter?** <br>
**Answer:** Looking at the <code>NetScheduleJobAdd</code> function, we see that it takes 3 parameters: <code>Servername</code>, <code>Buffer</code>, and <code>JobId</code>. <br>
![](/assets/images/Pasted image 20221005194015.png)<br>
The second parameter is <code>Buffer</code>. According to [Microsoft documentation for the NetScheduleJobAdd function](https://learn.microsoft.com/en-us/windows/win32/api/lmat/nf-lmat-netschedulejobadd), this is a pointer to an "AT_INFO" structure describing the job to submit. This struct contains the following information:<br>
![](/assets/images/Pasted image 20221005194341.png)<br>
Before the call to <code>NetScheduleJobAdd</code> we see a reference to <code>DLL3GetStructure</code>:<br>
![](/assets/images/Pasted image 20221005195326.png)<br>
Since DLL3 contains a command and a reference to a structure, I am going to assume that <code>NetScheduleJobAdd</code> gets its data for the Buffer parameter from here.<br>
![](/assets/images/Pasted image 20221005195558.png)<br>

**7. While running or debugging the program, you will see that it prints out three pieces of mystery data. What are the following: DLL 1 mystery data 1, DLL 2 mystery data 2, and DLL 3 mystery data 3?** <br>
**Answer:** The mystery data is as follows:
- **DLL1**
	- Current process ID
	- ![](/assets/images/Pasted image 20221005200816.png)<br>
	- ![](/assets/images/Pasted image 20221005200846.png)<br>
- **DLL2**
	- File handle to <code>temp.txt</code>
	- ![](/assets/images/Pasted image 20221005200945.png)<br>
	- ![](/assets/images/Pasted image 20221005201015.png)<br>
- **DLL3**
	- String that contains <code>ping www.malwareanalysisbook.com</code>
	- ![](/assets/images/Pasted image 20221005201138.png)<br>
	- ![](/assets/images/Pasted image 20221005201316.png)<br>

**8. How can you load DLL2.dll into IDA Pro so that it matches the load address used by OllyDbg** <br>
**Answer:** As we already discussed in question 3, DLL2.dll has a load address of <code>0x00330000</code> in OllyDbg. To match this in IDA, we have to select manual load and specify the new image base:<br>
![](/assets/images/Pasted image 20221005201643.png)<br>
![](/assets/images/Pasted image 20221005201752.png)<br>

### Comparing my answers to the Lab 9-3 solutions
Conclusions after comparison:
- We could have applied the <code>AT_INFO</code> structure to the data in <code>DLL3.dll</code> as follows:
	- Press [INSERT] while having the **Structures** window open and add the standard structure <code>AT_INFO</code>
		- ![](/assets/images/Pasted image 20221005202703.png)<br>
	- Next, open the **dword_1000B0A0** in memory
		- ![](/assets/images/Pasted image 20221005202951.png)<br>
	- Then select **Edit --> Struct Var** and click <code>AT_INFO</code>
		- ![](/assets/images/Pasted image 20221005203034.png)<br>
	- This will cause the data to be more readable!
		- ![](/assets/images/Pasted image 20221005203152.png)<br>

### Sources
- [Book: Practical Malware Analysis by Michael Sikorski and Andrew Honig](https://nostarch.com/malware)
- [Microsoft documentation for the NetScheduleJobAdd function](https://learn.microsoft.com/en-us/windows/win32/api/lmat/nf-lmat-netschedulejobadd)